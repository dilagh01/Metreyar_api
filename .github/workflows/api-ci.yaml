name: Full project structure setup

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  setup-project:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install poetry

      - name: Create backend project structure
        run: |
          mkdir -p backend/app/api/v1
          mkdir -p backend/app/models
          mkdir -p backend/app/schemas
          mkdir -p backend/app/database
          mkdir -p backend/tests
          mkdir -p backend/data/migrations

          # main.py
          cat << 'EOF' > backend/app/main.py
          from fastapi import FastAPI, Depends
          from sqlalchemy.ext.asyncio import AsyncSession
          from app.api.v1 import api_router
          from app.database.session import get_db

          app = FastAPI(title="Construction Estimator API")

          @app.get("/health")
          async def health_check(db: AsyncSession = Depends(get_db)):
              try:
                  await db.execute("SELECT 1")
                  return {"status": "healthy", "database": "connected"}
              except Exception:
                  return {"status": "healthy", "database": "disconnected"}

          app.include_router(api_router, prefix="/api/v1")
          EOF

          # __init__.py for v1
          cat << 'EOF' > backend/app/api/v1/__init__.py
          from fastapi import APIRouter
          from app.api.v1 import materials, estimations, categories

          api_router = APIRouter()
          api_router.include_router(materials.router, prefix="/materials", tags=["materials"])
          api_router.include_router(estimations.router, prefix="/estimations", tags=["estimations"])
          api_router.include_router(categories.router, prefix="/categories", tags=["categories"])
          EOF

          # materials.py
          cat << 'EOF' > backend/app/api/v1/materials.py
          from fastapi import APIRouter, Depends, HTTPException, status
          from sqlalchemy.ext.asyncio import AsyncSession
          from sqlalchemy.future import select
          from typing import List

          from app.database.session import get_db
          from app.models.material import Material
          from app.schemas.material import MaterialCreate, MaterialResponse, MaterialUpdate

          router = APIRouter()

          @router.get("/", response_model=List[MaterialResponse])
          async def get_materials(db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Material))
              return result.scalars().all()

          @router.post("/", response_model=MaterialResponse, status_code=status.HTTP_201_CREATED)
          async def create_material(material: MaterialCreate, db: AsyncSession = Depends(get_db)):
              db_material = Material(**material.dict())
              db.add(db_material)
              await db.commit()
              await db.refresh(db_material)
              return db_material

          @router.put("/{material_id}", response_model=MaterialResponse)
          async def update_material(material_id: int, material_update: MaterialUpdate, db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Material).where(Material.id == material_id))
              db_material = result.scalar_one_or_none()
              if not db_material:
                  raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="مصالح پیدا نشد")

              for field, value in material_update.dict(exclude_unset=True).items():
                  setattr(db_material, field, value)

              await db.commit()
              await db.refresh(db_material)
              return db_material

          @router.delete("/{material_id}", status_code=status.HTTP_204_NO_CONTENT)
          async def delete_material(material_id: int, db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Material).where(Material.id == material_id))
              db_material = result.scalar_one_or_none()
              if not db_material:
                  raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="مصالح پیدا نشد")

              await db.delete(db_material)
              await db.commit()
          EOF

          # estimations.py
          cat << 'EOF' > backend/app/api/v1/estimations.py
          from fastapi import APIRouter, Depends, HTTPException, status
          from sqlalchemy.ext.asyncio import AsyncSession
          from sqlalchemy.future import select
          from typing import List

          from app.database.session import get_db
          from app.models.estimation import Estimation
          from app.schemas.estimation import EstimationCreate, EstimationResponse, EstimationUpdate

          router = APIRouter()

          @router.get("/", response_model=List[EstimationResponse])
          async def get_estimations(db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Estimation))
              return result.scalars().all()

          @router.get("/{estimation_id}", response_model=EstimationResponse)
          async def get_estimation(estimation_id: int, db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Estimation).where(Estimation.id == estimation_id))
              estimation = result.scalar_one_or_none()
              if not estimation:
                  raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="برآورد پیدا نشد")
              return estimation

          @router.post("/", response_model=EstimationResponse, status_code=status.HTTP_201_CREATED)
          async def create_estimation(estimation: EstimationCreate, db: AsyncSession = Depends(get_db)):
              db_estimation = Estimation(**estimation.dict())
              db.add(db_estimation)
              await db.commit()
              await db.refresh(db_estimation)
              return db_estimation

          @router.put("/{estimation_id}", response_model=EstimationResponse)
          async def update_estimation(estimation_id: int, estimation_update: EstimationUpdate, db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Estimation).where(Estimation.id == estimation_id))
              db_estimation = result.scalar_one_or_none()
              if not db_estimation:
                  raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="برآورد پیدا نشد")

              for field, value in estimation_update.dict(exclude_unset=True).items():
                  setattr(db_estimation, field, value)

              await db.commit()
              await db.refresh(db_estimation)
              return db_estimation

          @router.delete("/{estimation_id}", status_code=status.HTTP_204_NO_CONTENT)
          async def delete_estimation(estimation_id: int, db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Estimation).where(Estimation.id == estimation_id))
              db_estimation = result.scalar_one_or_none()
              if not db_estimation:
                  raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="برآورد پیدا نشد")

              await db.delete(db_estimation)
              await db.commit()
          EOF

          # categories.py
          cat << 'EOF' > backend/app/api/v1/categories.py
          from fastapi import APIRouter, Depends, HTTPException, status
          from sqlalchemy.ext.asyncio import AsyncSession
          from sqlalchemy.future import select
          from typing import List

          from app.database.session import get_db
          from app.models.category import Category
          from app.schemas.category import CategoryCreate, CategoryResponse, CategoryUpdate

          router = APIRouter()

          @router.get("/", response_model=List[CategoryResponse])
          async def get_categories(db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Category))
              return result.scalars().all()

          @router.post("/", response_model=CategoryResponse, status_code=status.HTTP_201_CREATED)
          async def create_category(category: CategoryCreate, db: AsyncSession = Depends(get_db)):
              db_category = Category(**category.dict())
              db.add(db_category)
              await db.commit()
              await db.refresh(db_category)
              return db_category

          @router.put("/{category_id}", response_model=CategoryResponse)
          async def update_category(category_id: int, category_update: CategoryUpdate, db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Category).where(Category.id == category_id))
              db_category = result.scalar_one_or_none()
              if not db_category:
                  raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="دسته‌بندی پیدا نشد")

              for field, value in category_update.dict(exclude_unset=True).items():
                  setattr(db_category, field, value)

              await db.commit()
              await db.refresh(db_category)
              return db_category

          @router.delete("/{category_id}", status_code=status.HTTP_204_NO_CONTENT)
          async def delete_category(category_id: int, db: AsyncSession = Depends(get_db)):
              result = await db.execute(select(Category).where(Category.id == category_id))
              db_category = result.scalar_one_or_none()
              if not db_category:
                  raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="دسته‌بندی پیدا نشد")

              await db.delete(db_category)
              await db.commit()
          EOF

          # schemas: material
          cat << 'EOF' > backend/app/schemas/material.py
          from pydantic import BaseModel
          from typing import Optional
          from datetime import datetime

          class MaterialBase(BaseModel):
              name: str
              unit: str
              unit_price: float
              category_id: int

          class MaterialCreate(MaterialBase):
              pass

          class MaterialUpdate(BaseModel):
              name: Optional[str] = None
              unit: Optional[str] = None
              unit_price: Optional[float] = None
              category_id: Optional[int] = None

          class MaterialResponse(MaterialBase):
              id: int
              created_at: datetime
              updated_at: datetime

              class Config:
                  from_attributes = True
          EOF

          # schemas: estimation
          cat << 'EOF' > backend/app/schemas/estimation.py
          from pydantic import BaseModel
          from typing import Optional
          from datetime import datetime

          class EstimationBase(BaseModel):
              title: str
              description: Optional[str] = None
              total_cost: float = 0.0
              status: str = "draft"

          class EstimationCreate(EstimationBase):
              pass

          class EstimationUpdate(BaseModel):
              title: Optional[str] = None
              description: Optional[str] = None
              total_cost: Optional[float] = None
              status: Optional[str] = None

          class EstimationResponse(EstimationBase):
              id: int
              created_at: datetime
              updated_at: datetime

              class Config:
                  from_attributes = True
          EOF

          # schemas: category
          cat << 'EOF' > backend/app/schemas/category.py
          from pydantic import BaseModel
          from typing import Optional
          from datetime import datetime

          class CategoryBase(BaseModel):
              name: str
              description: Optional[str] = None

          class CategoryCreate(CategoryBase):
              pass

          class CategoryUpdate(BaseModel):
              name: Optional[str] = None
              description: Optional[str] = None

          class CategoryResponse(CategoryBase):
              id: int
              created_at: datetime
              updated_at: datetime

              class Config:
                  from_attributes = True
          EOF
