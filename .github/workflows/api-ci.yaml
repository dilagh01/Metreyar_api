name: Create Complete Project Structure

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - '.github/workflows/create-structure.yml'

jobs:
  create-structure:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Create complete project structure
      run: |
        # ایجاد ساختار دایرکتوری‌های اصلی
        echo "📁 ایجاد ساختار دایرکتوری‌ها..."
        mkdir -p backend/app/{api/v1,models,schemas,database,core,services}
        mkdir -p backend/tests
        mkdir -p data/migrations
        mkdir -p scripts
        mkdir -p docs
        
        # ایجاد فایل‌های __init__.py
        for dir in backend backend/app backend/app/api backend/app/api/v1 \
                 backend/app/models backend/app/schemas backend/app/database \
                 backend/app/core backend/app/services backend/tests; do
          touch "$dir/__init__.py"
        done
        
        echo "✅ ساختار دایرکتوری‌ها ایجاد شد"
        
    - name: Create main application files
      run: |
        echo "📝 ایجاد فایل‌های اصلی برنامه..."
        
        # فایل main.py
        cat > backend/app/main.py << 'EOL'
from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from sqlalchemy.ext.asyncio import AsyncSession
from app.database.session import engine, Base, get_db
from app.api.v1 import api_router
from app.core.config import settings

@asynccontextmanager
async def lifespan(app: FastAPI):
    # ایجاد جداول دیتابیس هنگام راه‌اندازی
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    # تمیزکاری هنگام خاموشی
    await engine.dispose()

app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.VERSION,
    description="API سیستم متره و برآورد پروژه‌های ساختمانی",
    lifespan=lifespan
)

# تنظیمات CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.BACKEND_CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# اضافه کردن routerها
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/")
async def root():
    return {
        "message": "خوش آمدید به سرویس متره‌یار",
        "version": settings.VERSION,
        "docs": "/docs"
    }

@app.get("/health")
async def health_check(db: AsyncSession = Depends(get_db)):
    try:
        await db.execute("SELECT 1")
        return {"status": "healthy", "database": "connected"}
    except Exception:
        return {"status": "healthy", "database": "disconnected"}
EOL

        echo "✅ فایل main.py ایجاد شد"
        
    - name: Create database configuration
      run: |
        echo "🗄️ ایجاد پیکربندی دیتابیس..."
        
        # فایل session.py
        cat > backend/app/database/session.py << 'EOL'
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from app.core.config import settings

# ایجاد موتور دیتابیس
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DEBUG,
    future=True
)

# ایجاد session factory
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)

Base = declarative_base()

# Dependency برای گرفتن session
async def get_db():
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()
EOL

        # فایل base.py برای مدل‌ها
        cat > backend/app/database/base.py << 'EOL'
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, DateTime, func

Base = declarative_base()

class BaseModel(Base):
    __abstract__ = True
    
    id = Column(Integer, primary_key=True, index=True)
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
EOL

        echo "✅ فایل‌های دیتابیس ایجاد شدند"
        
    - name: Create core configuration
      run: |
        echo "⚙️ ایجاد تنظیمات اصلی..."
        
        # فایل config.py
        cat > backend/app/core/config.py << 'EOL'
from pydantic_settings import BaseSettings
from typing import List
import os

class Settings(BaseSettings):
    PROJECT_NAME: str = "Metreyar API"
    VERSION: str = "1.0.0"
    API_V1_STR: str = "/api/v1"
    
    # دیتابیس
    DATABASE_URL: str = os.getenv(
        "DATABASE_URL", 
        "sqlite+aiosqlite:///./metreyar.db"
    )
    
    # امنیت
    SECRET_KEY: str = os.getenv("SECRET_KEY", "your-secret-key-here")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8  # 8 روز
    
    # CORS
    BACKEND_CORS_ORIGINS: List[str] = ["*"]
    
    # تنظیمات دیگر
    DEBUG: bool = os.getenv("DEBUG", "False").lower() == "true"
    
    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()
EOL

        echo "✅ فایل تنظیمات ایجاد شد"
        
    - name: Create models
      run: |
        echo "🏗️ ایجاد مدل‌های دیتابیس..."
        
        # مدل Material
        cat > backend/app/models/material.py << 'EOL'
from sqlalchemy import Column, String, Float, Text
from app.database.base import BaseModel

class Material(BaseModel):
    __tablename__ = "materials"
    
    name = Column(String(100), nullable=False, index=True)
    description = Column(Text)
    unit = Column(String(20), nullable=False)
    unit_price = Column(Float, nullable=False)
    category = Column(String(50), nullable=False)
    code = Column(String(20), unique=True)
EOL

        # مدل Estimation
        cat > backend/app/models/estimation.py << 'EOL'
from sqlalchemy import Column, String, Float, Text, ForeignKey
from sqlalchemy.orm import relationship
from app.database.base import BaseModel

class Estimation(BaseModel):
    __tablename__ = "estimations"
    
    title = Column(String(200), nullable=False)
    description = Column(Text)
    total_cost = Column(Float, default=0.0)
    status = Column(String(20), default="draft")
    
    items = relationship("EstimationItem", back_populates="estimation", cascade="all, delete-orphan")

class EstimationItem(BaseModel):
    __tablename__ = "estimation_items"
    
    estimation_id = Column(ForeignKey("estimations.id"), nullable=False)
    material_id = Column(ForeignKey("materials.id"), nullable=False)
    quantity = Column(Float, nullable=False)
    unit_price = Column(Float, nullable=False)
    total_price = Column(Float, nullable=False)
    notes = Column(Text)
    
    estimation = relationship("Estimation", back_populates="items")
    material = relationship("Material")
EOL

        # مدل Category
        cat > backend/app/models/category.py << 'EOL'
from sqlalchemy import Column, String, Text
from app.database.base import BaseModel

class Category(BaseModel):
    __tablename__ = "categories"
    
    name = Column(String(50), unique=True, nullable=False)
    description = Column(Text)
EOL

        echo "✅ مدل‌های دیتابیس ایجاد شدند"
        
    - name: Create API routes
      run: |
        echo "🌐 ایجاد endpointهای API..."
        
        # Router اصلی
        cat > backend/app/api/v1/__init__.py << 'EOL'
from fastapi import APIRouter
from app.api.v1 import materials, estimations, categories

api_router = APIRouter()

api_router.include_router(materials.router, prefix="/materials", tags=["materials"])
api_router.include_router(estimations.router, prefix="/estimations", tags=["estimations"])
api_router.include_router(categories.router, prefix="/categories", tags=["categories"])
EOL

        # Endpoint مصالح
        cat > backend/app/api/v1/materials.py << 'EOL'
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import List, Optional

from app.database.session import get_db
from app.models.material import Material
from app.schemas.material import MaterialCreate, MaterialResponse, MaterialUpdate

router = APIRouter()

@router.get("/", response_model=List[MaterialResponse])
async def get_materials(
    skip: int = 0,
    limit: int = 100,
    category: Optional[str] = None,
    search: Optional[str] = None,
    db: AsyncSession = Depends(get_db)
):
    query = select(Material)
    
    if category:
        query = query.where(Material.category == category)
    
    if search:
        query = query.where(Material.name.ilike(f"%{search}%"))
    
    result = await db.execute(query.offset(skip).limit(limit))
    materials = result.scalars().all()
    return materials

@router.get("/{material_id}", response_model=MaterialResponse)
async def get_material(material_id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Material).where(Material.id == material_id))
    material = result.scalar_one_or_none()
    
    if not material:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="مصالح مورد نظر یافت نشد"
        )
    
    return material

@router.post("/", response_model=MaterialResponse, status_code=status.HTTP_201_CREATED)
async def create_material(material: MaterialCreate, db: AsyncSession = Depends(get_db)):
    db_material = Material(**material.dict())
    db.add(db_material)
    await db.commit()
    await db.refresh(db_material)
    return db_material

@router.put("/{material_id}", response_model=MaterialResponse)
async def update_material(
    material_id: int, 
    material_update: MaterialUpdate, 
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Material).where(Material.id == material_id))
    db_material = result.scalar_one_or_none()
    
    if not db_material:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="مصالح مورد نظر یافت نشد"
        )
    
    for field, value in material_update.dict(exclude_unset=True).items():
        setattr(db_material, field, value)
    
    await db.commit()
    await db.refresh(db_material)
    return db_material

@router.delete("/{material_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_material(material_id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Material).where(Material.id == material_id))
    material = result.scalar_one_or_none()
    
    if not material:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="مصالح مورد نظر یافت نشد"
        )
    
    await db.delete(material)
    await db.commit()
EOL

        # Endpoint برآوردها
        cat > backend/app/api/v1/estimations.py << 'EOL'
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import List, Optional

from app.database.session import get_db
from app.models.estimation import Estimation
from app.schemas.estimation import EstimationCreate, EstimationResponse, EstimationUpdate

router = APIRouter()

@router.get("/", response_model=List[EstimationResponse])
async def get_estimations(
    skip: int = 0,
    limit: int = 100,
    status: Optional[str] = None,
    db: AsyncSession = Depends(get_db)
):
    query = select(Estimation)
    
    if status:
        query = query.where(Estimation.status == status)
    
    result = await db.execute(query.offset(skip).limit(limit))
    estimations = result.scalars().all()
    return estimations

@router.get("/{estimation_id}", response_model=EstimationResponse)
async def get_estimation(estimation_id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Estimation).where(Estimation.id == estimation_id))
    estimation = result.scalar_one_or_none()
    
    if not estimation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="برآورد مورد نظر یافت نشد"
        )
    
    return estimation

@router.post("/", response_model=EstimationResponse, status_code=status.HTTP_201_CREATED)
async def create_estimation(estimation: EstimationCreate, db: AsyncSession = Depends(get_db)):
    db_estimation = Estimation(**estimation.dict())
    db.add(db_estimation)
    await db.commit()
    await db.refresh(db_estimation)
    return db_estimation
EOL

        # Endpoint دسته‌بندی‌ها
        cat > backend/app/api/v1/categories.py << 'EOL'
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import List, Optional

from app.database.session import get_db
from app.models.category import Category
from app.schemas.category import CategoryCreate, CategoryResponse, CategoryUpdate

router = APIRouter()

@router.get("/", response_model=List[CategoryResponse])
async def get_categories(
    skip: int = 0,
    limit: int = 100,
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Category).offset(skip).limit(limit))
    categories = result.scalars().all()
    return categories

@router.post("/", response_model=CategoryResponse, status_code=status.HTTP_201_CREATED)
async def create_category(category: CategoryCreate, db: AsyncSession = Depends(get_db)):
    db_category = Category(**category.dict())
    db.add(db_category)
    await db.commit()
    await db.refresh(db_category)
    return db_category
EOL

        echo "✅ endpointهای API ایجاد شدند"
        
    - name: Create schemas
      run: |
        echo "📋 ایجاد schemaهای Pydantic..."
        
        # Schema مصالح
        cat > backend/app/schemas/material.py << 'EOL'
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class MaterialBase(BaseModel):
    name: str
    description: Optional[str] = None
    unit: str
    unit_price: float
    category: str
    code: Optional[str] = None

class MaterialCreate(MaterialBase):
    pass

class MaterialUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    unit: Optional[str] = None
    unit_price: Optional[float] = None
    category: Optional[str] = None
    code: Optional[str] = None

class MaterialResponse(MaterialBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True
EOL

        # Schema برآوردها
        cat > backend/app/schemas/estimation.py << 'EOL'
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime

class EstimationBase(BaseModel):
    title: str
    description: Optional[str] = None
    status: str = "draft"

class EstimationCreate(EstimationBase):
    pass

class EstimationUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    status: Optional[str] = None

class EstimationResponse(EstimationBase):
    id: int
    total_cost: float
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True
EOL

        # Schema دسته‌بندی‌ها
        cat > backend/app/schemas/category.py << 'EOL'
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class CategoryBase(BaseModel):
    name: str
    description: Optional[str] = None

class CategoryCreate(CategoryBase):
    pass

class CategoryUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None

class CategoryResponse(CategoryBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True
EOL

        echo "✅ schemaهای Pydantic ایجاد شدند"
        
    - name: Create test files
      run: |
        echo "🧪 ایجاد فایل‌های تست..."
        
        # تست اصلی
        cat > backend/tests/test_main.py << 'EOL'
from fastapi.testclient import TestClient
from backend.app.main import app

client = TestClient(app)

def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()

def test_health_check():
    response = client.get("/health")
    assert response.status_code == 200
    assert "status" in response.json()

def test_get_materials():
    response = client.get("/api/v1/materials/")
    assert response.status_code == 200
    assert isinstance(response.json(), list)
EOL

        echo "✅ فایل‌های تست ایجاد شدند"
        
    - name: Create configuration files
      run: |
        echo "📄 ایجاد فایل‌های پیکربندی..."
        
        # requirements.txt
        cat > requirements.txt << 'EOL'
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
aiosqlite==0.19.0
alembic==1.12.1
pydantic==2.5.0
pydantic-settings==2.1.0
python-multipart==0.0.6
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-dotenv==1.0.0
pytest==7.4.3
httpx==0.25.2
EOL

        # .env.example
        cat > .env.example << 'EOL'
# Database
DATABASE_URL=sqlite+aiosqlite:///./metreyar.db

# Security
SECRET_KEY=your-super-secret-key-change-in-production
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=1440

# Application
DEBUG=True
PROJECT_NAME=Metreyar API
VERSION=1.0.0
API_V1_STR=/api/v1
EOL

        # Dockerfile
        cat > Dockerfile << 'EOL'
FROM python:3.11-slim

WORKDIR /app

RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "backend.app.main:app", "--host", "0.0.0.0", "--port", "8000"]
EOL

        # docker-compose.yml
        cat > docker-compose.yml << 'EOL'
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    environment:
      - DATABASE_URL=sqlite+aiosqlite:///./metreyar.db
    command: uvicorn backend.app.main:app --reload --host 0.0.0.0 --port 8000
EOL

        # README.md
        cat > README.md << 'EOL'
# Metreyar API

سرویس API برای سیستم متره و برآورد پروژه‌های ساختمانی

## ویژگی‌ها

- مدیریت مصالح ساختمانی
- ایجاد و مدیریت برآوردها
- محاسبه خودکار هزینه‌ها
- دسته‌بندی مصالح
- API کاملاً RESTful

## راه‌اندازی

### با Docker

```bash
docker-compose up -d
